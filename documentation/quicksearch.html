<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"classes_Admin.js.html":{"id":"classes_Admin.js.html","title":"Source: classes/Admin.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/Admin.js 'use strict' /** * @namespace AdminGUI */ let AdminGUI = function(window, undefined) { let settings let controlKit let socket let pos let deletingRegion = false let deletingRegionWithColor = false let cleaningRegion = false let deletingRegionWithUName = false setTimeout(function init() { document.addEventListener('mousedown', adminMouseDown) pos = {} socket = SocketHandler.getSocket() settings = { /*logWorldData: function() { let worldData = WorldData.getWorldData() for (let i = 0; i &lt; worldData.length; i++) { for (let j = 0; j &lt; worldData[i].length; j++) { for (let voxPos in worldData[i][j]) { console.log('voxPos: ' + voxPos) } } } }*/ deleteRegion: { offText: 'Delete Region', onText: 'Deleting' }, deleteRegionWColor: { offText: 'Delete Region w/ Color', onText: 'Deleting Region w/ Color' }, cleanRegion: { offText: 'Clean Region', onText: 'Cleaning Region' }, deleteRegionWUName: { offText: 'Delete Region with Username', onText: 'Deleting Region with Username' }, username: '' } controlKit = GUIControlKit.getControlKit() initControlKit() // don't know why we need this $('#controlKit .panel').mousedown(function() { GUIControlKit.setClicked(true) // this has to be assigned here because // some elements don't exist on page load $('#controlKit *').mousedown(function() { GUIControlKit.setClicked(true) }) }) }, 400) function initControlKit() { let mainPanel = controlKit.addPanel({ label: 'Admin', align: 'left', width: 275, fixed: false }) .addButton(settings.deleteRegion.offText, function() { toggleAdminControl('deleteRegion', true) deletingRegion = true }) .addButton(settings.deleteRegionWColor.offText, function() { toggleAdminControl('deleteRegionWColor', true) deletingRegionWithColor = true }) .addButton(settings.cleanRegion.offText, function() { toggleAdminControl('cleanRegion', true) cleaningRegion = true }) .addButton(settings.deleteRegionWUName.offText, function() { toggleAdminControl('deleteRegionWUName', true) deletingRegionWithUName = true }) .addStringInput(settings, 'username', { label: 'Username', onChange: function() { console.log('onChange') } }) } function toggleAdminControl(name, on) { if (on) { $('#controlKit [value=&quot;' + settings[name].offText + '&quot;]').css('color', 'red') $('#controlKit [value=&quot;' + settings[name].offText + '&quot;]').val(settings[name].onText) } else { $('#controlKit [value=&quot;' + settings[name].onText + '&quot;]').css('color', '') $('#controlKit [value=&quot;' + settings[name].onText + '&quot;]').val(settings[name].offText) } } function adminMouseDown(e) { if (User.stateIsHighlight()) return if (e.which === 1) leftDown(e) } /** * Handle a left mouse button * down event * @memberOf Mouse * @access private * @param {Event} e */ function leftDown(e) { let intersect = Mouse.getMouseIntersects(e).closestIntx if (intersect) { if (deletingRegionWithUName || deletingRegion || deletingRegionWithColor || cleaningRegion) { let p = intersect.point.clone().initWorldPos() p.add(intersect.face.normal).worldToGrid() let spssp = ((GUIControlKit.getSSSP() - 1) / 2) let c1 = new THREE.Vector3(p.x - spssp, p.y, p.z - spssp).initGridPos() let c2 = new THREE.Vector3(p.x + spssp, p.y, p.z + spssp).initGridPos() let intxGPos = intersect.point.clone().initWorldPos() intxGPos = intxGPos.add(intersect.face.normal).worldToGrid() let particleSystem = GameScene.getPSystem() let c1Sid = VoxelUtils.getSectionIndices(c1) let c2Sid = VoxelUtils.getSectionIndices(c2) let count = 0 let toRemove = [] let voxels = WorldData.getWorldData() for (let x = c1Sid.a; x &lt;= c2Sid.a; x++) { for (let z = c1Sid.b; z &lt;= c2Sid.b; z++) { for (let voxPos in voxels[x][z]) { let gPos = VoxelUtils.coordStrParse(voxPos) if (gPos.x &gt;= c1.x &amp;&amp; gPos.z &gt;= c1.z &amp;&amp; gPos.x &lt;= c2.x &amp;&amp; gPos.z &lt;= c2.z) { if (deletingRegionWithColor) { if (WorldData.getVoxel(gPos).hColor !== VoxelUtils.hexStringToDec(GUIControlKit.getBlockColor())) continue } if (cleaningRegion) { let sid = new VoxelUtils.Tuple(x, z) if (touchingOwnColor(sid, gPos)) continue } if (deletingRegionWithUName) { if (WorldData.getVoxel(gPos).username !== settings.username) continue } toRemove.push(gPos) let sid = new VoxelUtils.Tuple(x, z) let vox = voxels[x][z][voxPos] let wPos = gPos.clone().gridToWorld() particleSystem.hidePixel(sid, vox.pIdx) WorldData.removeVoxel(gPos) } } } } if (toRemove.length &gt; 0) { socket.emit('batch delete', toRemove, function(deletedVoxels) { console.log(`removed ${deletedVoxels.length} of ${toRemove.length} voxels.`) }) } toggleAdminControl('deleteRegion', false) toggleAdminControl('deleteRegionWColor', false) toggleAdminControl('cleanRegion', false) toggleAdminControl('deleteRegionWUName', false) deletingRegion = false deletingRegionWithColor = false cleaningRegion = false deletingRegionWithUName = false } } } function colorsMatch(gPos, color) { var vox = WorldData.getVoxel(gPos) return vox &amp;&amp; (parseInt(vox.hColor) === parseInt(color)) } function touchingOwnColor(sid, gPos) { var origVox = WorldData.getVoxel(gPos) var color = origVox.hColor for (var x = -1; x &lt;= 1; x++) { for (var y = -1; y &lt;= 1; y++) { for (var z = -1; z &lt;= 1; z++) { if (x === 0 &amp;&amp; y === 0 &amp;&amp; z === 0 || y &lt; 0) continue var posCheck = new THREE.Vector3(gPos.x + x, gPos.y + y, gPos.z + z) if (colorsMatch(posCheck, color)) return true } } } return false } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_GameScene.js.html":{"id":"classes_GameScene.js.html","title":"Source: classes/GameScene.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/GameScene.js 'use strict' /** * Manages the game scene (camera, scene, lights, etc) * and related game assets * @namespace GameScene */ let GameScene = function(window, undefined) { if (!Detector.webgl) Detector.addGetWebGLMessage() /*------------------------------------* :: Class Variables *------------------------------------*/ // basic scene els let scene let camera let renderer let noaarenderer let aarenderer // with antialiasing // the game scene div let container // lights let trackingDirLight let globalDirLight let ambientLight // planes let voxelPlane let voxGeom let mapControlsPlane let rspColors let nullMat // grid let gridGeom let gridOutlineGeom let gridConfig let gridLines let outlineLines // meshes let ghostMesh let deleteMesh /*------------------------------------* :: Public methods *------------------------------------*/ /** * Initializes the game scene. Must be * called before anything else. * @memberOf GameScene * @access public */ function init() { scene = new THREE.Scene() container = document.getElementById('container') gridConfig = Config.getGrid() ; (function _initCamera() { let config = { fov: 45, near: 100, far: 300000, distMult: 0.125 } let aspect = window.innerWidth / window.innerHeight camera = new THREE.PerspectiveCamera(config.fov, aspect, config.near, config.far) camera.position.set(10000 * config.distMult, 15000 * config.distMult, 10000 * config.distMult) camera.lookAt(new THREE.Vector3()) // look at 0, 0, 0 })() ; (function _initRenderer() { function setSharedConfig(r) { r.setClearColor('#ffffff') r.sortObjects = false r.setSize(window.innerWidth, window.innerHeight) r.setClearColor(0, 0) } aarenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }) noaarenderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }) setSharedConfig(aarenderer) setSharedConfig(noaarenderer) if (Config.getGeneral().aaOnByDefault) renderer = aarenderer else renderer = noaarenderer container.appendChild(renderer.domElement) })() ; (function _initLights() { ambientLight = new THREE.AmbientLight(0xffffff, 0.45) scene.add(ambientLight) let pos = gridConfig.sqPerSideOfGrid / 2 * 50 globalDirLight = new THREE.DirectionalLight(0xffffff, 0.6) globalDirLight.position.set(pos, pos / 2, 0) globalDirLight.target.position.set(0,0,0) scene.add(globalDirLight) trackingDirLight = new THREE.DirectionalLight(0xffffff, 0.4) scene.add(trackingDirLight.target) scene.add(trackingDirLight) })() ; (function _initPlanes() { let gridSize = gridConfig.size let blockSize = gridConfig.blockSize nullMat = new THREE.MeshBasicMaterial({ visible: false }) // this is the plane the voxels are actually placed on. initVoxelPlane(gridConfig.size) // the floor grid lines initFloorGrid(gridConfig.sqPerSideOfGrid) // This is the plane that MapControls uses to // pan and rotate ; (function _initControlsPlane() { let ctrlGeom = new THREE.PlaneGeometry(gridSize * 40, gridSize * 40) ctrlGeom.rotateX(-Math.PI / 2) mapControlsPlane = new THREE.Mesh(ctrlGeom, nullMat) mapControlsPlane.name = 'plane' scene.add(mapControlsPlane) })() })() ; (function _initHoverVoxels() { // voxel shown when hovering grid (function _initGhostVoxel() { let blockSize = Config.getGrid().blockSize let ghostGeo = new THREE.CubeGeometry(blockSize, blockSize, blockSize) let ghostMaterial = new THREE.MeshBasicMaterial({ color: GUIControlKit.getBlockColor(), transparent: true, opacity: 0.5, visible: false }) ghostMesh = new THREE.Mesh(ghostGeo, ghostMaterial) scene.add(ghostMesh) })() ; // cube rendered over voxel when hovered and shift is held (function _initDeleteVoxel() { let size = gridConfig.blockSize + (gridConfig.blockSize * 0.02) let redXTexture = new THREE.ImageUtils.loadTexture('/img/redx.png') let deleteGeo = new THREE.CubeGeometry(size, size, size) let deleteMat = new THREE.MeshPhongMaterial({ map: redXTexture, color: 0xffffff, transparent: true, opacity: 0.4, visible: false }) deleteMesh = new THREE.Mesh(deleteGeo, deleteMat) scene.add(deleteMesh) })() })() window.addEventListener('resize', onWindowResize) } /** * Renders the scene * @memberOf GameScene * @access public */ function render() { renderer.render(scene, camera) } /** * Setup the voxel plane with the given size * @memberOf GameScene * @access public * @param {Number} size Size of the plane */ function initVoxelPlane(size) { let stdSideLen = size * 2 + gridConfig.blockSize Raycast.remove(voxelPlane) voxGeom = new THREE.PlaneGeometry(stdSideLen, stdSideLen) voxGeom.rotateX(-Math.PI / 2) nullMat = new THREE.MeshBasicMaterial({ visible: false }) voxelPlane = new THREE.Mesh(voxGeom, nullMat) voxelPlane.name = 'plane' Raycast.add(voxelPlane) //let axisHelper = new THREE.AxisHelper(150) //scene.add(axisHelper) } /** * Setup the floor grid * @memberOf GameScene * @access public * @param {Number} gridSize Grid size */ function initFloorGrid(gridSize) { scene.remove(gridLines) scene.remove(outlineLines) gridGeom = new THREE.Geometry() gridOutlineGeom = new THREE.Geometry() function drawLine(geom, i) { geom.vertices.push(new THREE.Vector3(-size - 25, 0, i)) geom.vertices.push(new THREE.Vector3( size + 25, 0, i)) geom.vertices.push(new THREE.Vector3(i, 0, -size - 25)) geom.vertices.push(new THREE.Vector3(i, 0, size + 25)) } let step = gridConfig.blockSize let size = (gridSize / 2) * gridConfig.blockSize // grid outline drawLine(gridOutlineGeom, -size - 25) drawLine(gridOutlineGeom, size + 25) // grid for (let i = -size + 25; i &lt;= size - 25; i += step) { drawLine(gridGeom, i) } let material = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.15, transparent: true }) gridLines = new THREE.LineSegments(gridGeom, material) outlineLines = new THREE.LineSegments(gridOutlineGeom, material) scene.add(gridLines) scene.add(outlineLines) } /** * Turn the delete mesh visibility on or off * @memberOf GameScene * @access public * @param {boolean} visible set visiblity */ function setDeleteMeshVis(visible) { deleteMesh.material.visible = visible } /** * Turn the ghost mesh visibility on or off * @memberOf GameScene * @access public * @param {boolean} visible set visibility */ function setGhostMeshVis(visible) { ghostMesh.material.visible = visible } /** * Set the color of the ghost mesh * @memberOf GameScene * @access public * @param {number} hColor Hex color to set */ function setGhostMeshColor(hColor) { ghostMesh.material.color.setHex(hColor) render() } /** * Update the position / visibility of the ghost mesh * based on the given intersect * @memberOf GameScene * @access public * @param {THREE.Intersect} intersect The intersect used to * set the position */ function updateGhostMesh(intersect) { let gPos = intersect.point.clone().initWorldPos() gPos.add(intersect.face.normal).worldToGrid() if (!VoxelUtils.validBlockLocation(gPos) || Keys.isShiftDown() || !User.stateIsDefault()) { setGhostMeshVis(false) return } setGhostMeshVis(true) let gmp = ghostMesh.position gmp.copy(intersect.point) gmp.add(intersect.face.normal) gmp.initWorldPos() gmp.snapToGrid() } /** * Update the position and visibility of the * delete mesh based on the given intersect * @memberOf GameScene * @access public * @param {THREE.Intersect} intersect The intersect * used to set the position */ function updateDeleteMesh(intersect) { if (intersect.object.name === 'plane' || !Keys.isShiftDown()) { setDeleteMeshVis(false) return } setDeleteMeshVis(true) let dmp = deleteMesh.position dmp.copy(intersect.point) dmp.sub(intersect.face.normal) dmp.initWorldPos() dmp.snapToGrid() } /** * Switch between the antialiasing * renderer and the non-antialiasing renderer * @access public * @memberOf GameScene */ function switchRenderer() { removeCanvas() if (renderer === aarenderer) renderer = noaarenderer else renderer = aarenderer container.appendChild(renderer.domElement) onWindowResize() } /** * Adds an object to the scene * @memberOf GameScene * @access public * @param {THREE.Object} obj The object to add */ function addToScene(obj) { scene.add(obj) } /** * Remove an object from the scene * @memberOf GameScene * @access public * @param {THREE.Object} obj The object to remove */ function removeFromScene(obj) { scene.remove(obj) } /** * Remove the canvas from the game container * @memberOf GameScene * @access public */ function removeCanvas() { container.removeChild(container.getElementsByTagName('canvas')[0]) } /** * Set the position and target of the direcitonal light * @memberOf GameScene * @access public * @param {VoxelUtils.WorldVector3} position World position to set * @param {VoxelUtils.WorldVector3} target What the light should look at (optional) */ function setDirLightPos(position, target) { trackingDirLight.position.set(position.x, position.y, position.z) if (target) trackingDirLight.target.position.set(target.x, 500, target.z) } /******************Getters *************/ function getMapControlsPlane() { return mapControlsPlane } function getCamera() { return camera } function getScene() { return scene } /*------------------------------------* :: Private methods *------------------------------------*/ /** * Resizes on the scene when the window * is resized * @memberOf GameScene * @access private */ function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight camera.updateProjectionMatrix() renderer.setSize(window.innerWidth, window.innerHeight) render() } /*********** expose public methods *************/ return { init: init, removeCanvas: removeCanvas, switchRenderer: switchRenderer, addToScene: addToScene, removeFromScene: removeFromScene, setDeleteMeshVis: setDeleteMeshVis, setGhostMeshVis: setGhostMeshVis, setGhostMeshColor: setGhostMeshColor, updateGhostMesh: updateGhostMesh, updateDeleteMesh: updateDeleteMesh, getMapControlsPlane: getMapControlsPlane, getScene: getScene, getCamera: getCamera, setDirLightPos: setDirLightPos, render: render, initFloorGrid: initFloorGrid, initVoxelPlane: initVoxelPlane } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_GUIButtons.js.html":{"id":"classes_GUIButtons.js.html","title":"Source: classes/GUIButtons.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/GUIButtons.js 'use strict' /** * Manages the game's bootstrap GUI buttons * @namespace GUIButtons */ let GUIButtons = (function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ // export let exported let matFilename let fromBlankProj let animSpeed /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf GUIButtons * @access public */ function init() { $(&quot;.btn&quot;).mouseup(function() { $(this).blur() }) matFilename = 'voxelMats' fromBlankProj = false animSpeed = 185 initModals() initProjectModals() initDownloadButtons() } /** * Save current work as a new project * @memberOf GUIButtons * @access public */ function saveAsProject() { fromBlankProj = true User.setProjectNeedsSave(false) if (User.getUName() === 'Guest') { $('#login-info').css('display', 'block') showLogin() if (!formOnCreate) { formOnCreate = true animateForm(0) } } else { $('#new-project-modal').modal() } } /*------------------------------------* :: Private Methods *------------------------------------*/ /** * Get the OBJ + MTL files for this project * @memberOf GUIButtons * @access private */ function exportVoxels() { let exporter = new THREE.OBJExporter() exported = exporter.parse(GameScene.getScene(), matFilename) } /** * Show the login modal * @memberOf GUIButtons * @access private * @param {Number} animSpeed Speed to animate at */ function showLogin(animSpeed) { $(document).trigger('modalOpened') $('#login-modal').css('z-index', 3) $('#modal-background').css('z-index', 2) $('#login-modal').animate({ opacity: 1 }, { queue: false }, animSpeed) $('#modal-background').animate({ opacity: 0.5 }, { queue: false }, animSpeed) } /** * Hide the login modal * @memberOf GUIButtons * @access private * @param {Number} animSpeed Speed to animate at */ function hideLogin(animSpeed) { $('#login-modal').animate({ opacity: 0 }, { queue: false, duration: animSpeed, done: function() { $('#login-modal').css('z-index', -1) } }) $('#modal-background').animate({ opacity: 0 }, { queue: false, duration: animSpeed, done: function() { $('#modal-background').css('z-index', -1) $(document).trigger('modalClosed') } }) } /** * Initialize some standard modal behavior * @memberOf GUIButtons * @access private */ function initModals() { $(document).trigger('modalClosed') // triggered $('.modal').on('hidden.bs.modal', function() { $(document).trigger('modalClosed') }) $('.modal').on('shown.bs.modal', function() { $(document).trigger('modalOpened') }) initLoginModal() } /** * Initilize the login modal * @memberOf GUIButtons * @access private */ function initLoginModal() { // open login modal $('#button-login').click(function() { showLogin(animSpeed) if (formOnCreate) { animateForm(0) formOnCreate = false } }) // logout $('#button-logout').click(function() { let url = window.location.protocol + '//' + window.location.host window.location = url + '/signout' }) // hide modal on click background $('#modal-background').click(function() { hideLogin(animSpeed) }) } /** * Initialize the download buttons * @memberOf GUIButtons * @access private */ function initDownloadButtons() { // download obj $('#download-obj').click(function() { exportVoxels() let objBlob = new Blob([exported.obj], { type: 'text/plain' }) saveAs(objBlob, 'voxels.obj') }) // download mtl $('#download-mtl').click(function() { exportVoxels() let mtlBlob = new Blob([exported.mtl], { type: 'text/plain' }) saveAs(mtlBlob, matFilename + '.mtl') }) // download JSON $('#download-json').click(function() { let jsonBlob = new Blob([JSON.stringify(GameScene.getScene())], { type: 'text/json' }) saveAs(jsonBlob, 'voxels.json') }) } /** * Initialize the new project / show projects modals * @memberOf GUIButtons * @access private */ function initProjectModals() { // open new project modal $('.new-project').click(function() { $('#new-project-modal').modal() }) $('#save-curr-project').click(function() { SocketHandler.saveProject(User.getCurrentProject().name, function(err) { if (err) { alert('Error: Project was not saved.') console.log(err) } else { alert('Project saved!') $('#save-curr-project').css('display', 'none') User.setProjectNeedsSave(false) } }) }) // prompt user to name / save project $('#save-as-project').click(function() { saveAsProject() }) // attempt to create a new project $('#new-project-form').submit(function(e) { e.preventDefault() $('#new-project-modal').modal('hide') let pjtName = $('#new-project-modal #new-project-name').val() let uname = User.getUName() let voxels = [] if (fromBlankProj) { fromBlankProj = false voxels = WorldData.getVoxelsArr() } if (uname &amp;&amp; uname !== 'Guest') { SocketHandler.createProject(pjtName, voxels, function(err) { let url = window.location.protocol + '//' + window.location.host if (err) { console.log(err) let msg let responses = SocketResponses.get() if (err === responses.unexpectedErr) msg = 'Unexpected error.' else if (err === responses.noProjName) msg = 'You must specify a project name.' else if (err === responses.duplicateProj) msg = 'A project with that name already exists.' else msg = 'Unknown.' alert('Error: Project not created. ' + msg) } else { console.log('Created project ' + pjtName) window.location = url + '/user/' + uname + '/' + pjtName } }) } else { console.log('Guests should be able to create new projects..??') } }) // load all user projects in project // modal and open it $('#user-projects').click(function() { SocketHandler.requestProjects(function(projects) { let modalBody = $('#projects-modal .modal-body') $(modalBody).children().remove() let len = projects.length let i = 0 projects.forEach(function(project) { let h5 = $('&lt;h5&gt;').html(project.name) let open = $('&lt;a&gt;', { href: '/user/' + User.getUName() + '/' + project.name }).html('Open') let del = $('&lt;a&gt;', { href: '/user/' + User.getUName() + '/delete/' + project.name, class: 'delete-proj' }).html('Delete') let hr = $('&lt;hr&gt;') modalBody.append(h5) modalBody.append(open) modalBody.append(' | ') modalBody.append(del) if (i &lt; len - 1) modalBody.append(hr) i++ }) $('#projects-modal').modal() // confirm proj delete $('.delete-proj').click(function(e) { if (!confirm('Are you sure you wan\\'t to delete this project?')) { e.preventDefault() } }) }) }) } return { init: init, saveAsProject: saveAsProject } })(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_GUIControlKit.js.html":{"id":"classes_GUIControlKit.js.html","title":"Source: classes/GUIControlKit.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/GUIControlKit.js 'use strict' /** * Manages the game's ControlKit GUI * @namespace GUIControlKit */ let GUIControlKit = function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ let settings let controlKit let guiClicked /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf GUIControlKit * @access public */ function init() { let startingBlockColor = randomHexColor().getHashHexString() settings = { colors: { blockColor: startingBlockColor, prevBlockColor: startingBlockColor, saved: [], randomColor: setRandomBlockColor }, debug: { logWorldData: function() { let worldData = WorldData.getWorldData() for (let i = 0; i &lt; worldData.length; i++) { for (let j = 0; j &lt; worldData[i].length; j++) { for (let voxPos in worldData[i][j]) { console.log('voxPos: ' + voxPos) } } } }, hoveredUser: '', userName: User.getUName() }, userSettings: { useAA: Config.getGeneral().aaOnByDefault }, coords: '', workSpace: { size: Config.getGrid().sqPerSideOfGrid, range: [20, 200] }, connectedClients: 0 } controlKit = new ControlKit() guiClicked = false initControlKit() let uname = User.getUName() if (!uname || uname === 'Guest') showModal() } /** * Given an intersect, extract the color of the intersected * block (if it was a block that was intersected) and assign it * to the blockColor + update the Game scenes ghost mesh * @memberOf GUIControlKit * @access public * @param {THREE.Intersect} intersect The intersect */ function setPickColor(intersect) { let iObj = intersect.object let objName = iObj.name let pickColor if (objName !== 'plane') { if (objName === 'voxel') { pickColor = intersect.object.material.color let hColor = pickColor.getHex() let hexString = '#' + pickColor.getHexString() GameScene.setGhostMeshColor(hColor ^ 0x4C000000) settings.colors.blockColor = hexString pushToSavedColors() controlKit.update() } } togglePickColor() } /** * Get the current block color * @memberOf GUIControlKit * @access public * @return {number} The block color */ function getBlockColor() { return settings.colors.blockColor } /** * Return whether or not the GUI was click * before the mouse click event was received * @memberOf GUIControlKit * @access public * @return {number} The block color */ function wasClicked() { return guiClicked } /** * Set clicked to true or false * @memberOf GUIControlKit * @memberOf GUIControlKit * @access public */ function setClicked(clicked) { guiClicked = clicked } /** * Display the currently hovered coordinates in the GUI * @memberOf GUIControlKit * @access public * @param {THREE.Intersect} planeIntx The plane intersect */ function setCoords(planeIntx) { if (planeIntx) { let gPos = (planeIntx.point).clone().add(planeIntx.face.normal).worldToGrid() settings.coords = '(' + gPos.x + ', ' + gPos.z + ')' controlKit.update() } } /** * If the pick color button is clicked, * set the users state to pickcolor * @memberOf GUIControlKit * @access private */ function togglePickColor() { if (User.stateIsDefault()) { $('#controlKit [value=&quot;Color Picker&quot;]').val('Click Voxel') User.setPickState() } else if (User.stateIsPick()) { $('#controlKit [value=&quot;Click Voxel&quot;]').val('Color Picker') User.setDefaultState() } } function getControlKit() { return controlKit } function setConnectedClients(num) { settings.connectedClients = num } function getWorkspaceSize() { return settings.workSpace.size } /*------------------------------------* :: Private Methods *------------------------------------*/ /** * Add the necessary elements to the gui * @memberOf GUIControlKit * @access private */ function initControlKit() { let mainPanel = controlKit.addPanel({ label: 'Controls', align: 'right', width: 325 }) mainPanel.addSubGroup({ label: 'Colors' }) .addColor(settings.colors, 'blockColor', { presets: 'saved', label: 'Block Color', onChange: function(newColor) { // get decimal let dColor = VoxelUtils.hexStringToDec(newColor) GameScene.setGhostMeshColor(dColor) pushToSavedColors() } }) .addButton('Color Picker', togglePickColor) .addButton('Random Color', settings.colors.randomColor) mainPanel.addSubGroup({ label: 'Info' }) .addStringOutput(settings, 'coords', { label: 'Coordinates' }) .addButton('Show Controls', function() { $(document).trigger('modalOpened') showModal() }) mainPanel.addSubGroup({ label: 'Settings' }) .addCheckbox(settings.userSettings, 'useAA', { label: 'Antialiasing', onChange: function() { GameScene.switchRenderer() } }) .addSlider(settings.workSpace, 'size', 'range', { label: 'Workspace Size', step: 2, dp: 0, onChange: function() { if (settings.workSpace.size % 2 !== 0) settings.workSpace.size = settings.workSpace.size - 1 GameScene.initFloorGrid(settings.workSpace.size) GameScene.initVoxelPlane(settings.workSpace.size * (Config.getGrid().blockSize / 2)) } }) // if it was the gui that was clicked, // save this fact so that we can prevent // world actions from taking place behind it $('#controlKit *, .btn').mousedown(function() { guiClicked = true // this has to be assigned here because // some elements don't exist on page load $('#controlKit *').mousedown(function() { guiClicked = true }) }) } /** * Show the welcome modal * @memberOf GUIControlKit * @access private */ function showModal() { $('#welcome-modal').modal() } /** * Set the block color to a random color * @memberOf GUIControlKit * @access private */ function setRandomBlockColor() { let randColor = randomHexColor() GameScene.setGhostMeshColor(randColor.getHex()) settings.colors.blockColor = randColor.getHashHexString() pushToSavedColors() controlKit.update() } /** * Push the old block color to our saved colors * @memberOf GUIControlKit * @access private */ function pushToSavedColors() { let maxColors = Config.getGUI().maxSavedColors let savedColors = settings.colors.saved let prevBlockColor = settings.colors.prevBlockColor let idx = savedColors.indexOf(prevBlockColor) if (idx !== -1) savedColors.splice(idx, 1) savedColors.unshift(prevBlockColor) if (savedColors.length &gt; maxColors) savedColors.pop() settings.colors.prevBlockColor = settings.colors.blockColor } /** * Get a random hex color * @memberOf GUIControlKit * @access private * @return {number} The random hex color */ function randomHexColor() { return new THREE.Color(0xffffff * Math.random()) } /*********** expose public methods *************/ return { init: init, destroy: destroy, getBlockColor: getBlockColor, wasClicked: wasClicked, setClicked: setClicked, setPickColor: setPickColor, setCoords: setCoords, togglePickColor: togglePickColor, getControlKit: getControlKit, setConnectedClients: setConnectedClients, getWorkspaceSize: getWorkspaceSize } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_Keys.js.html":{"id":"classes_Keys.js.html","title":"Source: classes/Keys.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/Keys.js 'use strict' /** * Manages and routes keyboard events * @namespace Keys */ let Keys = function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ let keyStates /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf Keys * @access public */ function init() { keyStates = { shiftDown: false, ctrlDown: false } $(document).on('modalClosed', addEventListeners) $(document).on('modalOpened', removeEventListeners) } /** * Is the shift key currently down? * @memberOf Keys * @access public * @return {boolean} */ function isShiftDown() { return keyStates.shiftDown } /** * Is the control key currently down? * @memberOf Keys * @access public * @return {boolean} */ function isCtrlDown() { return keyStates.ctrlDown } /** * Set the state of the control key. * This is needed in scearios where the * key events are not triggered (window * out of focus) * @memberOf Keys * @access public * @param {boolean} value Value to set it to */ function setCtrlDown(value) { keyStates.ctrlDown = value } /** * Set the state of the shift key. * This is needed in scearios where the * key events are not triggered (window * out of focus) * @memberOf Keys * @access public * @param {boolean} value Value to set it to */ function setShiftDown(value) { keyStates.shiftDown = value } /*------------------------------------* :: Private Methods *------------------------------------*/ /** * Add keyboard event listeners to the document * @memberOf Keys * @access private */ function addEventListeners() { document.addEventListener('keydown', keyDown) document.addEventListener('keyup', keyUp) } /** * Remove keyboard event listeners from the document * @memberOf Keys * @access private */ function removeEventListeners() { document.removeEventListener('keydown', keyDown) document.removeEventListener('keyup', keyUp) } /** * Route keydown events * @memberOf Keys * @access private * @param {Event} e */ function keyDown(e) { switch (e.keyCode) { case 27: escDown() break case 16: shiftDown() break case 17: ctrlDown() break } } /** * Route keyup events * @memberOf Keys * @access private * @param {Event} e */ function keyUp(e) { switch (e.keyCode) { case 16: shiftUp() break case 17: ctrlUp() break } } /** * Handle an escape down event * @memberOf Keys * @access private */ function escDown() { if (!User.stateIsDefault()) { if (User.stateIsPick()) GUIControlKit.togglePickColor() User.setDefaultState() } } /** * Handle a shift down event * @memberOf Keys * @access private */ function shiftDown() { keyStates.shiftDown = true Mouse.forceTriggerMouseMove() } /** * Handle a control down event * @memberOf Keys * @access private */ function ctrlDown() { keyStates.ctrlDown = true } /** * Handle a control up event * @memberOf Keys * @access private */ function ctrlUp() { keyStates.ctrlDown = false } /** * Handle a shift up event * @memberOf Keys * @access private */ function shiftUp() { keyStates.shiftDown = false Mouse.forceTriggerMouseMove() } /*********** expose public methods *************/ return { init: init, isShiftDown: isShiftDown, isCtrlDown: isCtrlDown, setCtrlDown: setCtrlDown, setShiftDown: setShiftDown } }() Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"Main.js.html":{"id":"Main.js.html","title":"Source: Main.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: Main.js 'use strict' /** * Initializes all classes and triggers * loading of data into scene * @namespace Main */ var Main = function() { $(document).ready(function() { window.onbeforeunload = function(e) { if (User.projectNeedsSave()) return '' return } // prevent middle click directional scroll $('body').mousedown(function(e) { if (e.button == 1) e.preventDefault() }) // initialize classes User.init() Mouse.init() Keys.init() GUIControlKit.init() GUIButtons.init() Raycast.init() GameScene.init() WorldData.init() MapControls.init() SocketHandler.init() if (njProject) WorldData.loadIntoScene(njProject.voxels) else GameScene.render() }) }() Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_MapControls.js.html":{"id":"classes_MapControls.js.html","title":"Source: classes/MapControls.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/MapControls.js 'use strict' /** * @author Jacek Jankowski / http://grey-eminence.org/ * It is an adaptation of the three.js OrbitControls class to map environments */ // further modified by Davis Yarbrough to work with this project /** * Handles the zoom, pan, and rotate controls * @namespace MapControls */ let MapControls = function() { let target let raycastPlane let camera let config // constraints let camMinxz let camMaxxz let camMiny let camMaxy function init() { target = new THREE.Vector3() raycastPlane = GameScene.getMapControlsPlane() camera = GameScene.getCamera() config = Config.getMapControls() camMinxz = config.camMinxz camMaxxz = config.camMaxxz camMiny = config.camMiny camMaxy = config.camMaxy // set target at center let e = $.Event('mousemove') e.clientX = 0 e.clientY = 0 onMouseDown(e) // initialize the directional light position GameScene.setDirLightPos(camera.position, target) } // internals let EPS = 0.000001 let rotateStart = new THREE.Vector2() let rotateEnd = new THREE.Vector2() let rotateDelta = new THREE.Vector2() let panStart = new THREE.Vector3() let panDelta = new THREE.Vector3() let phiDelta = 0 let thetaDelta = 0 let lastPosition = new THREE.Vector3() let STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2 } let state = STATE.NONE let vector, projector, intersects, raycaster = new THREE.Raycaster() function update() { if (lastPosition.distanceTo(camera.position) &gt; 0) { GameScene.render() lastPosition.copy(camera.position) } } function getIntersects(xy) { raycaster.setFromCamera(xy, camera) return raycaster.intersectObject(raycastPlane) } function onMouseDown(event) { let intersects if (event.button === 1) { state = STATE.PAN intersects = getIntersects(Mouse.getMousePos()) if (intersects.length &gt; 0) { panStart = intersects[0].point } } else if (event.button === 2) { state = STATE.ROTATE intersects = getIntersects({ x: 0, y: 0 }) if (intersects.length &gt; 0) { target = intersects[0].point } rotateStart.set(event.clientX, event.clientY) } document.addEventListener('mousemove', onMouseMove, false) document.addEventListener('mouseup', onMouseUp, false) } function onMouseMove(event) { event.preventDefault() if (state === STATE.PAN) { let intersects = getIntersects(Mouse.getMousePos()) if (intersects.length &gt; 0) { panDelta = intersects[0].point let delta = new THREE.Vector3() delta.subVectors(panStart, panDelta) //console.log(camera.position) let pos = camera.position.clone() pos.addVectors(pos, delta) if ((pos.x &lt; camMinxz &amp;&amp; pos.x &lt; camera.position.x) || (pos.x &gt; camMaxxz &amp;&amp; pos.x &gt; camera.position.x) || (pos.z &lt; camMinxz &amp;&amp; pos.z &lt; camera.position.z) || (pos.z &gt; camMaxxz &amp;&amp; pos.z &gt; camera.position.z)) return camera.position.addVectors(camera.position, delta) GameScene.setDirLightPos(camera.position) update() } } else if (state === STATE.ROTATE) { let element = document === document ? document.body : document rotateEnd.set(event.clientX, event.clientY) rotateDelta.subVectors(rotateEnd, rotateStart) thetaDelta -= 2 * Math.PI * rotateDelta.x / element.clientWidth * config.rotateSpeed phiDelta -= 2 * Math.PI * rotateDelta.y / element.clientHeight * config.rotateSpeed let cPosition = camera.position let offset = cPosition.clone().sub(target) // angle from z-axis around y-axis let theta = Math.atan2(offset.x, offset.z) // angle from y-axis let phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y) theta += thetaDelta phi += phiDelta // restrict phi to be between desired limits phi = Math.max(config.minPolarAngle, Math.min(config.maxPolarAngle, phi)) // restrict phi to be betwee EPS and PI-EPS phi = Math.max(EPS, Math.min(Math.PI - EPS, phi)) let radius = offset.length() // restrict radius to be between desired limits radius = Math.max(config.minDistance, Math.min(config.maxDistance, radius)) offset.x = radius * Math.sin(phi) * Math.sin(theta) offset.y = radius * Math.cos(phi) offset.z = radius * Math.sin(phi) * Math.cos(theta) cPosition.copy(target).add(offset) camera.lookAt(target) GameScene.setDirLightPos(cPosition, target) thetaDelta = 0 phiDelta = 0 rotateStart.copy(rotateEnd) update() } } function onMouseUp( /* event */ ) { document.removeEventListener('mousemove', onMouseMove, false) document.removeEventListener('mouseup', onMouseUp, false) state = STATE.NONE } function onMouseWheel(event) { let delta = 0 if (event.wheelDelta) { // WebKit / Opera / Explorer 9 delta = event.wheelDelta } else if (event.deltaY) { // Firefox delta = -event.deltaY * zoomSpeed * 25 } let zoomOffset = new THREE.Vector3() let te = camera.matrix.elements zoomOffset.set(te[8], te[9], te[10]) zoomOffset.multiplyScalar(delta * -config.zoomSpeed * camera.position.y / 1000) let pos = camera.position.clone() pos.addVectors(pos, zoomOffset) if ((delta &lt; 0 &amp;&amp; pos.y &gt; camMaxy) || (delta &gt; 0 &amp;&amp; pos.y &lt; camMiny) || (pos.x &lt; camMinxz &amp;&amp; pos.x &lt; camera.position.x) || (pos.x &gt; camMaxxz &amp;&amp; pos.x &gt; camera.position.x) || (pos.z &lt; camMinxz &amp;&amp; pos.z &lt; camera.position.z) || (pos.z &gt; camMaxxz &amp;&amp; pos.z &gt; camera.position.z)) return camera.position.addVectors(camera.position, zoomOffset) GameScene.setDirLightPos(camera.position) update() } function ctxMenu(e) { e.preventDefault() } $(document).on('modalClosed', function() { document.addEventListener('contextmenu', ctxMenu) document.addEventListener('mousedown', onMouseDown) document.addEventListener('wheel', onMouseWheel) }) $(document).on('modalOpened', function() { document.removeEventListener('contextmenu', ctxMenu) document.removeEventListener('mousedown', onMouseDown) document.removeEventListener('wheel', onMouseWheel) }) return { init: init } }() Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_Mouse.js.html":{"id":"classes_Mouse.js.html","title":"Source: classes/Mouse.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/Mouse.js 'use strict' /** * Manages and routes Mouse events * @namespace Mouse */ let Mouse = function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ let pos /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf Mouse * @access public */ function init() { pos = {} $(document).on('modalClosed', addEventListeners) $(document).on('modalOpened', removeEventListeners) } /** * Force trigger a mouse move event. This is * needed when certain changes are made that * require the specific functionality of the * mouse move event but cannot be extracted into * another function * @memberOf Mouse * @access public */ function forceTriggerMouseMove() { let e = $.Event('mousemove') e.clientX = pos.clientX e.clientY = pos.clientY mouseMove(e) } /**************** getters ******************/ function getMousePos() { return pos } /*------------------------------------* :: Private Methods *------------------------------------*/ /** * Route a mouse down event * @memberOf Mouse * @access private * @param {Event} e */ function mouseDown(e) { if (GUIControlKit.wasClicked()) { GUIControlKit.setClicked(false) return } if (e.which === 1) leftDown(e) } /** * Handle a left mouse button * down event * @memberOf Mouse * @access private * @param {Event} e */ function leftDown(e) { e.preventDefault() let intersect = getMouseIntersects(e).closestIntx if (intersect) { // only act if we intersected something let intxGPos = intersect.point.clone().initWorldPos() intxGPos = intxGPos.add(intersect.face.normal).worldToGrid() if (VoxelUtils.validBlockLocation(intxGPos)) { if (!User.canAct()) return User.resetActionTimer() if (User.stateIsPick()) GUIControlKit.setPickColor(intersect) else { // create or delete if (Keys.isShiftDown()) { // delete voxel VoxelActions.deleteVoxelAtIntersect(intersect, function(success) { if (success) forceTriggerMouseMove() }) } else { // create voxel VoxelActions.createVoxelAtIntersect(intersect, function(success) { if (success) forceTriggerMouseMove() }) } } } } } /** * Handle a mouse move event * @memberOf Mouse * @access private * @param {Event} e */ function mouseMove(e) { e.preventDefault() if (e.ctrlKey) Keys.setCtrlDown(e.ctrlKey) if (e.shiftKey) Keys.setShiftDown(e.shiftKey) pos.clientX = e.clientX pos.clientY = e.clientY let intersects = getMouseIntersects(e) let intersect = intersects.closestIntx if (intersect) { // only act if we intersected something GUIControlKit.setCoords(intersects.planeIntx) if (User.stateIsDefault()) { GameScene.updateGhostMesh(intersect) GameScene.updateDeleteMesh(intersect) } } GameScene.render() } /** * This gets the objects that the mouse * is currently intersecting based on the event\\ * @memberOf Mouse * @access private * @param {Event} e * @return {object} * @return {{closestIntx: THREE.Intersect, planeIntx: THREE.Intersect}} closestIntx is * the object the mouse intersected that the is closest to the raycast origin. planeIntx * is the voxelPlane intersect, if there is one */ function getMouseIntersects(e) { let camera = GameScene.getCamera() pos.x = (e.clientX / window.innerWidth) * 2 - 1 pos.y = -(e.clientY / window.innerHeight) * 2 + 1 let intersects = Raycast.getIntersects(pos, camera) let minDist = Number.MAX_VALUE let closestIntx let planeIntx intersects.forEach(function(intx) { if (intx.distance &lt; minDist) { closestIntx = intx minDist = intx.distance } if (intx.object.name === 'plane') planeIntx = intx }) return { closestIntx: closestIntx, planeIntx: planeIntx } } /** * Add mouse event listeners to the document * @memberOf Mouse * @access private */ function addEventListeners() { // we are using a jQuery bind here so we can force // trigger a mouseMove event from mouseDown $(document).mousemove(mouseMove) document.addEventListener('mousedown', mouseDown) } /** * Remove mouse event listeners to the document * @memberOf Mouse * @access private */ function removeEventListeners() { $(document).unbind('mousemove') document.removeEventListener('mousedown', mouseDown) } /*********** expose public methods *************/ return { init: init, forceTriggerMouseMove: forceTriggerMouseMove, getMouseIntersects: getMouseIntersects, getMousePos: getMousePos } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_Raycast.js.html":{"id":"classes_Raycast.js.html","title":"Source: classes/Raycast.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/Raycast.js 'use strict' /** * Manages raycasting operations * @namespace Raycast */ let Raycast = function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ let raycastArr // array of THREE.js meshes to raycast against let raycaster /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf Raycast * @access public */ function init() { raycastArr = [] raycaster = new THREE.Raycaster() } /** * Add a mesh to raycast against * @memberOf Raycast * @access public * @param {THREE.Mesh} mesh The mesh */ function add(mesh) { raycastArr.push(mesh) } /** * Stop raycasting against * a mesh * @memberOf Raycast * @access public * @param {THREE.Mesh} The mesh */ function remove(mesh) { for (let i = 0, len = raycastArr.length; i &lt; len; i++) { if (raycastArr[i] === mesh) { raycastArr.splice(i, 1) break } } } /** * Get intersects based on the given * position and camera * @memberOf Raycast * @access public * @param {number} pos The position * @param {THREE.Camera} camera The camera * @return {Object[]} Array of intersects */ function getIntersects(pos, camera) { raycaster.setFromCamera(pos, camera) return raycaster.intersectObjects(raycastArr) } /*********** expose public methods *************/ return { init: init, add: add, remove: remove, getIntersects: getIntersects } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_SocketHandler.js.html":{"id":"classes_SocketHandler.js.html","title":"Source: classes/SocketHandler.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/SocketHandler.js 'use strict' /** * Manages socket events * @namespace SocketHandler */ let SocketHandler = function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ let socket /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf SocketHandler * @access public */ function init() { socket = io.connect() initSocketOns() } /** * Tells the server to make a temporary * cache for some user data so it can * be recovered on page reload * @memberOf SocketHandler * @access public * @param {string} uname Temp username (not yet confirmed registered) */ function cacheTempUser(uname) { let voxels = WorldData.getVoxelsArr() if (voxels.length) socket.emit('cache temp user', uname, voxels) } /** * Get the list of projects for this * user from the server * @memberOf SocketHandler * @access public * @param {Function} cb Callback to execute on completion */ function requestProjects(cb) { socket.emit('get projects', cb) } /** * Save the project with the specified name * @memberOf SocketHandler * @access public * @param {string} pjtName Name of the project to save * @param {Function} cb Callback to execute on completion */ function saveProject(pjtName, cb) { socket.emit('save project', pjtName, cb) } /** * Create a new project with the given * name / initial voxels * @memberOf SocketHandler * @access public * @param {string} pjtName Name of the new project * @param {Object[]} voxels Array of voxels to add to the project * @param {Function} cb Callback to execute on completion */ function createProject(pjtName, voxels, cb) { socket.emit('create project', pjtName, voxels, cb) } /** * Send a &quot;block removed&quot; socket emit * with the given grid position * @memberOf SocketHandler * @access public * @param {VoxelUtils.GridVector3} gPos The grid * position of the voxel to remove * @param {Function} cb Callback to call with * a boolean indicating success */ function emitBlockRemoved(gPos, cb) { let project = User.getCurrentProject() let pjtName = project ? project.name : 'guest' socket.emit('block removed', { x: gPos.x, y: gPos.y, z: gPos.z }, pjtName, cb) } /** * Send a &quot;block added&quot; socket emit * with the given grid position and color * @memberOf SocketHandler * @access public * @param {VoxelUtils.GridVector3} gPos The grid * position of the voxel to add * @param {string} hexString Hex color of the voxel * we are adding * @param {Function} cb Callback to call with * a boolean indicating success */ function emitBlockAdded(gPos, hexString, cb) { let project = User.getCurrentProject() let pjtName = project ? project.name : 'guest' socket.emit('block added', { color: VoxelUtils.hexStringToDec(hexString), position: { x: gPos.x, y: gPos.y, z: gPos.z } }, pjtName, cb) } /** * Get the socket object * @return {Object} The socket * @memberOf SocketHandler * @access public */ function getSocket() { return socket } /*------------------------------------* :: Private Methods *------------------------------------*/ /** * Initialize socket.on events * @memberOf SocketHandler * @access private */ function initSocketOns() { socket.on('update clients', function(num) { GUIControlKit.setConnectedClients(num) }) socket.on('multiple logins', function() { alert('You are already logged in!') GameScene.removeCanvas() GUIControlKit.destroy() }) socket.on('block added', function(block) { let pos = block.position let gPos = new THREE.Vector3(pos.x, pos.y, pos.z).initGridPos() let tColor = new THREE.Color(block.color) let username = block.username VoxelActions.createVoxelAtGridPos(gPos, '#' + tColor.getHexString(), username) GameScene.render() }) socket.on('block removed', function(pos) { let gPos = new THREE.Vector3(pos.x, pos.y, pos.z).initGridPos() VoxelActions.deleteVoxelAtGridPos(gPos) }) socket.on('load temp cache', function(voxels) { WorldData.loadIntoScene(voxels) GameScene.render() $('#save-as-project').css('display', 'block') GUIButtons.saveAsProject() }) } /*********** expose public methods *************/ return { init: init, emitBlockAdded: emitBlockAdded, emitBlockRemoved: emitBlockRemoved, getSocket: getSocket, requestProjects: requestProjects, createProject: createProject, saveProject: saveProject, cacheTempUser: cacheTempUser } }() Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_User.js.html":{"id":"classes_User.js.html","title":"Source: classes/User.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/User.js 'use strict' /** * Manages and stores information on the user * and user state * @namespace User */ let User = function(window, undefined) { /*------------------------------------* :: Class Variables *------------------------------------*/ let states let state let actionTimer let currentHoveredUser let actionDelay let currentProject let projNeedsSave /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf User * @access public */ function init() { states = { DEFAULT: 0, PICKCOLOR: 1 } setDefaultState() actionDelay = Config.getGeneral().actionDelay // from editor.nunjucks currentProject = njProject projNeedsSave = false let now = Date.now() actionTimer = new Date(now - actionDelay) } /** * Reset the action timer to delay * actions again * @memberOf User * @access public */ function resetActionTimer() { actionTimer = new Date() } /** * Checks if the user can act * based on the actionDelay config * setting and the last time acted * @memberOf User * @access public * @return {boolean} */ function canAct() { let msSinceAct = new Date(new Date() - actionTimer).getTime() return msSinceAct &gt; actionDelay } /*********** setters *************/ /** * Set the user state to default * @memberOf User * @access public */ function setDefaultState() { state = states.DEFAULT $('body').css('cursor', 'url(/img/default.cur), auto') } /** * Set the user state to PICKCOLOR * @memberOf User * @access public */ function setPickState() { state = states.PICKCOLOR $('body').css('cursor', 'url(/img/picker.cur), auto') } function setProjectNeedsSave(val) { projNeedsSave = val } /*********** getters *************/ function getCurrentProject() { return currentProject } function getUName() { let username = $('#user #username').html() if (!username) username = 'Guest' let res = /[a-zA-Z0-9_]+/.exec(username) if (res) username = res[0] return username } function getCurrentHoveredUser() { return currentHoveredUser } function getActionDelay() { return actionDelay } function projectNeedsSave() { return projNeedsSave } function stateIsPick() { return state === states.PICKCOLOR } function stateIsDefault() { return state === states.DEFAULT } /*********** expose public methods *************/ return { init: init, canAct: canAct, getUName: getUName, resetActionTimer: resetActionTimer, stateIsPick: stateIsPick, stateIsDefault: stateIsDefault, setDefaultState: setDefaultState, setPickState: setPickState, getCurrentHoveredUser: getCurrentHoveredUser, getActionDelay: getActionDelay, getCurrentProject: getCurrentProject, projectNeedsSave: projectNeedsSave, setProjectNeedsSave: setProjectNeedsSave } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_Validation.js.html":{"id":"classes_Validation.js.html","title":"Source: classes/Validation.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/Validation.js /** * A class to assist with validating function arguments. * @namespace Validation */ let Validation = (function(window, undefined) { /** * An illegal argument exception * @memberOf! Validation * @type {object} */ function IllegalArgumentException(message) { this.message = message; } /** * Helper function for validateArguments. Checks the arguments * and ensures that none of them are undefined and that the length * matches the parameter length * * @memberOf Validation * @param args {arguments} Arguments property of the function we * are validating * @param len {number} How long the arguments array should be */ function validateLenAndDefined(args, len) { if (!args || args.length !== len) return false; let undefFlag = true; args.forEach(function(obj) { if (obj === null || obj === undefined) undefFlag = false; }); return undefFlag; } /** * Helper function for validateArguments. Checks the arguments against * the array of types and makes sure the types are correct * * @memberOf Validation * @param args {arguments} Arguments property of the function we * are validating * @param types {Array} Array of types to check against arguments. These * should be strings of javascript types or validation instance functions. * e.g. ['string', 'number', 'object'] * @returns {number} Index of the invalid argument, -1 if none */ function validateArgumentTypes(args, types) { let i = 0, ret = -1, done = false; args.forEach(function(arg) { if (done) return; if (typeof types[i] === 'function') { if (!(types[i].call(args[i]))) { console.warn('args[' + i + '] is not valid according to ' + (types[i].name ? types[i].name : 'an instance function')); ret = i; done = true; } } else if (typeof types[i] === 'string' || typeof types[i] === 'object') { if (!(typeof args[i] === types[i])) { ret = i; done = true; } } else { if (!args[i] || !types[i]) { console.warn('args[' + i + '] is not valid according to an instance boolean, or types[' + i + '] is not defined'); ret = i; done = true; } } i++; }); return ret; } /** * Takes an arguments object, an array of types, and a function * and verifies that the number of arguments matches the number of * types, that all arguments are defined, and that all arguments * match their respective type in the &quot;types&quot; array. If an instance * validation function is passed, it will be used for type validation. * If something is invalid, an appropriate error is thrown. * * @memberOf Validation * @param args {arguments} Arguments property of the function we * are validating * @param types {Array} Array of types to check against arguments. These * should be strings of javascript types or validation instance functions. * e.g. ['string', 'number', 'object'] * @param func {function} The function we are validating */ function validateArguments(args, types, func) { args = Array.prototype.slice.call(args); if (validateLenAndDefined(args, func.length)) { let paramNames = getParams(func); let i = validateArgumentTypes(args, types); if (i &gt;= 0) { let str; if (types[i] &amp;&amp; !(typeof types[i] === 'function')) str = 'param ' + paramNames[i] + ' is not a valid ' + types[i]; else str = 'param ' + paramNames[i] + ' is not valid'; throw new IllegalArgumentException(str); } } else throw new IllegalArgumentException('Undefined or missing arguments'); } return { validateArguments: validateArguments } })(window, undefined); Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_VoxelActions.js.html":{"id":"classes_VoxelActions.js.html","title":"Source: classes/VoxelActions.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/VoxelActions.js 'use strict' /** * This module manages the creation and deletion * of voxels * @namespace VoxelActions */ let VoxelActions = function(window, undefined) { /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Creates a voxel mesh at the specified * grid position * @memberOf VoxelActions * @access public * @param {VoxelUtils.GridVector3} gPos The grid position * to create the voxel at * @param {string} hexString Hex color of the voxel */ function createVoxelAtGridPos(gPos, hexString) { let voxelMesh = VoxelUtils.initVoxel({ color: VoxelUtils.hexStringToDec(hexString), gPos: gPos }) voxelMesh.wireMesh = createWireMesh(voxelMesh, gPos, hexString) WorldData.addMesh(gPos, voxelMesh) Raycast.add(voxelMesh) GameScene.addToScene(voxelMesh) GameScene.addToScene(voxelMesh.wireMesh) GameScene.render() } /** * Creates a voxel at a position based on the * given intersect * @memberOf VoxelActions * @access public * @param {THREE.Intersect} intersect The intersect * @param {Function} done Called upon completion */ function createVoxelAtIntersect(intersect, done) { let gPos = intersect.point gPos.add(intersect.face.normal) gPos.initWorldPos() gPos.worldToGrid() let hexString = GUIControlKit.getBlockColor() if (User.getCurrentProject()) { SocketHandler.emitBlockAdded(gPos, hexString, function(response) { let responses = SocketResponses.get() if (response === responses.success) { $('#save-curr-project').css('display', 'block') User.setProjectNeedsSave(true) createVoxelAtGridPos(gPos, hexString) return done(true) } else { //console.debug(response) if (response === 'max') { let maxVoxels = Config.getGeneral().maxGlobalBlocks alert('Maximum voxel limit of ' + maxVoxels + ' reached.') } return done(false) } }) } else { $('#save-as-project').css('display', 'block') if (User.getUName() !== 'Guest') User.setProjectNeedsSave(true) createVoxelAtGridPos(gPos, hexString) return done(true) } } /** * Deletes a voxel at a position based on the * given intersect * @memberOf VoxelActions * @access public * @param {THREE.Intersect} intersect The intersect * @param {Function} done Called upon completion */ function deleteVoxelAtIntersect(intersect, done) { let iobj = intersect.object if (iobj.name === 'voxel') { let gPos = VoxelUtils.getGridPositionFromIntersect(intersect) if (!gPos) return done(false) if (User.getCurrentProject()) { SocketHandler.emitBlockRemoved(gPos, function(response) { let responses = SocketResponses.get() if (response === responses.success) { $('#save-curr-project').css('display', 'block') User.setProjectNeedsSave(true) deleteVoxelAtGridPos(gPos) return done(true) } else { // handle errs console.debug(response) return done(false) } }) } else { deleteVoxelAtGridPos(gPos) return done(true) } } } /** * Deletes a specified voxel mesh. This is a voxel that has been added to the * selected region since its selection * @memberOf VoxelActions * @access private * @param {VoxelUtils.GridVector3} gPos Grid position of the voxel to delete */ function deleteVoxelAtGridPos(gPos) { let vox = WorldData.getVoxel(gPos) let coordStr = VoxelUtils.getCoordStr(gPos) GameScene.removeFromScene(vox.wireMesh) GameScene.removeFromScene(vox) let username = vox.isMesh ? vox.userData.username : vox.username WorldData.removeVoxel(gPos) Raycast.remove(vox) GameScene.render() } /*------------------------------------* :: Private Methods *------------------------------------*/ function createWireMesh(mesh, gPos, hexString) { let rgb = VoxelUtils.hexStringToRgb(hexString) let col = new THREE.Color(rgb.r - 0.05, rgb.g - 0.05, rgb.b - 0.05) let wireMesh = new THREE.LineSegments( new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({color: col, linewidth: 3}) ) let wPos = gPos.clone().gridToWorld() wireMesh.position.copy(wPos) return wireMesh } /*********** expose public methods *************/ return { createVoxelAtGridPos: createVoxelAtGridPos, createVoxelAtIntersect: createVoxelAtIntersect, deleteVoxelAtGridPos: deleteVoxelAtGridPos, deleteVoxelAtIntersect: deleteVoxelAtIntersect } }(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_VoxelUtils.js.html":{"id":"classes_VoxelUtils.js.html","title":"Source: classes/VoxelUtils.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/VoxelUtils.js 'use strict' /** * Contains a number of utility functions for working with voxels * @namespace VoxelUtils */ let VoxelUtils = (function(window, undefined) { /** * A coordinate string defining the grid position of a voxel. * Formatted as &quot;x[-]{0,1}[0-9]+y[-]{0,1}[0-9]+z[-]{0,1}[0-9]+&quot;. * So &quot;x-12y3z15&quot; (x: -12, y: 3, z: 15) would be a valid example. * @memberOf VoxelUtils * @typedef {string} coordStr */ /** * A THREE.Vector3 that represents a grid coordinate. Can * be initialized with &quot;new THREE.Vector3().initGridPos()&quot;, * or by calling &quot;vec3.worldToGrid()&quot;. * @memberOf VoxelUtils * @typedef {THREE.Vector3} GridVector3 */ /** * A THREE.Vector3 that represents a world coordinate. Can * be initialized with &quot;new THREE.Vector3().initWorldPos()&quot;, * or by calling &quot;vec3.gridToWorld()&quot;. * @memberOf VoxelUtils * @typedef {THREE.Vector3} WorldVector3 */ /*------------------------------------* :: Public methods *------------------------------------*/ /** * Check if a string is propery formatted as a VoxelUtils.coordStr * @memberOf VoxelUtils * @access public * @return {boolean} */ String.prototype.isCoordStr = function() { let formatReg = /x[-]*\\d+y[-]*\\d+z[-]*\\d+/ return !!formatReg.exec(this) } /** * Get a hash hex string ('#1f3c5d86') from a THREE.Color * @memberOf VoxelUtils * @access public * @return {string} The hash hex string */ THREE.Color.prototype.getHashHexString = function() { return '#' + this.getHexString() } /** * Sets a THREE.Vector3's values to the * center of the closest world &quot;anchor&quot;. I.e. the position * that would be used to set the world coordinates of a * voxel at that location (multiples of 50 for x and z, * (multiples of 50) + 25 for y). * @memberOf VoxelUtils * @access public */ THREE.Vector3.prototype.snapToGrid = function() { this.worldToGrid() this.gridToWorld() } /** * Converts a THREE.Vector3's values from world * coordinates to grid coordinates. * @memberOf VoxelUtils * @access public */ THREE.Vector3.prototype.worldToGrid = function() { let blockSize = Config.getGrid().blockSize this.divideScalar(blockSize) this.setComponent(0, Math.round(this.x)) this.setComponent(1, Math.floor(this.y)) this.setComponent(2, Math.round(this.z)) this.isGridPos = true this.isWorldPos = false return this } /** * Converts a THREE.Vector3's values from grid * coordinates to world coordinates. * @memberOf VoxelUtils */ THREE.Vector3.prototype.gridToWorld = function() { let blockSize = Config.getGrid().blockSize this.multiplyScalar(blockSize) this.setComponent(1, this.y + 25) this.isWorldPos = true this.isGridPos = false return this } /** * Marks this vector as a grid position (game coordinates). * @memberOf VoxelUtils * @access public * @returns {VoxelUtils.GridVector3} This object */ THREE.Vector3.prototype.initGridPos = function() { this.isGridPos = true return this } /** * Marks this vector as a world position (scene coordinates). * @memberOf VoxelUtils * @access public * @returns {VoxelUtils.WorldVector3} This object */ THREE.Vector3.prototype.initWorldPos = function() { this.isWorldPos = true return this } /** * Tuple object. * @memberOf VoxelUtils * @access public * @class Tuple * @type {object} * @property {number} a First value * @property {number} b Second value */ function Tuple(a, b) { return { a: a, b: b, /** * Checks is this is valid tuple. * For validation * @instance * @memberOf VoxelUtils.Tuple * @method isValidTuple */ isValidTuple: function() { return typeof this.a === 'number' &amp;&amp; typeof this.b === 'number' } } } /** * Takes a coordinate string, parses it and returns * it as a THREE.Vector3. * * @memberOf VoxelUtils * @access public * @param {VoxelUtils.coordStr} coordStr Coordinate string representing * a grid position * @returns {THREE.Vector3} Parsed position vector */ function coordStrParse(coordStr) { let xreg = /x[-]*\\d+/, yreg = /y[-]*\\d+/, zreg = /z[-]*\\d+/ let pos = { x: parseInt(xreg.exec(coordStr)[0].slice(1)), y: parseInt(yreg.exec(coordStr)[0].slice(1)), z: parseInt(zreg.exec(coordStr)[0].slice(1)) } return new THREE.Vector3(pos.x, pos.y, pos.z).initGridPos() } /** * Takes a THREE.Vector3 and converts it to a coordinate * string. * * @memberOf VoxelUtils * @access public * @param {VoxelUtils.GridVector3} gPos Position in grid coordinates * @returns {VoxelUtils.coordStr} Grid coordinate string */ function getCoordStr(gPos) { return &quot;x&quot; + gPos.x + &quot;y&quot; + gPos.y + &quot;z&quot; + gPos.z } /** * Check if the given position is within * the global height limit * @memberOf VoxelUtils * @access public * @param {VoxelUtils.GridVector3} gPos The position * @return {boolean} */ function validHeight(gPos) { // too high? if (gPos.y &gt;= Config.get().maxVoxelHeight) { if (!Keys.shiftDown() &amp;&amp; !User.stateIsPick()) { alert('Max height reached.') return false } } // too low? if (gPos.y &lt; 0) return false return true } /** * Check if the given position is both * within the selection bounds and less * than the global height limit * @memberOf VoxelUtils * @access public * @param {VoxelUtils.GridVector3} gPos The position * we are checking * @return {boolean} */ function validBlockLocation(gPos) { return validHeight(gPos) &amp;&amp; withinGridBoundaries(gPos) } /** * Checks if a position is within * the boundaries of the grid * @memberOf VoxelUtils * @access public * @param {VoxelUtils.GridVector3} gPos The grid position * @return {boolean} */ function withinGridBoundaries(gPos) { let spsg = GUIControlKit.getWorkspaceSize() let minxz = -(spsg / 2) let maxxz = spsg / 2 return (gPos.x &gt;= minxz &amp;&amp; gPos.z &gt;= minxz &amp;&amp; gPos.x &lt;= maxxz &amp;&amp; gPos.z &lt;= maxxz) } /** * Initializes a voxel mesh with the specified position * @memberOf VoxelUtils. * @memberOf VoxelUtils * @access public * @param {object} args Voxel parameters * @param {GridVector3} args.gPos Grid position * @param {number} args.color Hex color * @return {THREE.Mesh} The threejs voxel mesh */ function initVoxel(args) { let blockSize = Config.getGrid().blockSize let wPos = args.gPos.clone() wPos.gridToWorld() let geom = new THREE.BoxGeometry(blockSize, blockSize, blockSize), material = new THREE.MeshLambertMaterial({ color: args.color }) let mesh = new THREE.Mesh(geom, material) mesh.castShadow = true mesh.name = 'voxel' mesh.position.set(wPos.x, wPos.y, wPos.z) mesh.updateMatrix() return mesh } /** * Counts the number of root attributes in an * object. * * @memberOf VoxelUtils * @access public * @param {object} obj The object * @returns {number} */ function countObjAttrs(obj) { let num = 0 for (let attr in obj) { num++ } return num } /** * Get the grid position from an intersect * @memberOf VoxelUtils * @access public * @param {THREE.Intersect} intersect The intersect * @return {VoxelUtils.GridVector3} Grid position, null on none */ function getGridPositionFromIntersect(intersect) { let gPos let iobj = intersect.object if (iobj.name !== 'plane') { if (iobj.name === 'voxel') { gPos = iobj.position.clone() gPos.initWorldPos() gPos.worldToGrid() } else { gPos = (intersect.point).clone().sub(intersect.face.normal) gPos.worldToGrid() } return gPos } return null } /** * Convert a hexadecimal string to decimal * @memberOf VoxelUtils * @access public * @param {string} hexString The hex string * @return {number} The decimal value */ function hexStringToDec(hexString) { return parseInt(hexString.substring(1), 16) } /** * Convert a hexadecimal string to RGB * @memberOf VoxelUtils * @access public * @param {string} hexString The hex string * @return {Object} RGB object */ function hexStringToRgb(hexString) { let hs = hexString.charAt(0) === '#' ? hexString.substring(1) : hexString return { r: parseInt(hs.substring(0, 2), 16) / 255, g: parseInt(hs.substring(2, 4), 16) / 255, b: parseInt(hs.substring(4, 6), 16) / 255 } } /*********** expose public methods *************/ return { withinGridBoundaries: withinGridBoundaries, validBlockLocation: validBlockLocation, coordStrParse: coordStrParse, hexStringToRgb: hexStringToRgb, getCoordStr: getCoordStr, initVoxel: initVoxel, countObjAttrs: countObjAttrs, Tuple: Tuple, buildOutlineGeom: buildOutlineGeom, hexStringToDec: hexStringToDec, getGridPositionFromIntersect: getGridPositionFromIntersect } })(window) Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes_WorldData.js.html":{"id":"classes_WorldData.js.html","title":"Source: classes/WorldData.js","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Source: classes/WorldData.js 'use strict' /** * Manages the world state (location and * color of all voxels) * @namespace WorldData */ let WorldData = function(window, undefined) { /** * An object containing information on all of the * voxels currently in the world, where keys are * {@link VoxelUtils.coordStr} and values can be either * a THREE.Mesh (a newly placed voxel) or a {@link WorldData.VoxelInfo} * The structure looks like this: *&lt;pre&gt;&lt;code&gt; * { * 'x12y10z-5': {@link WorldData.VoxelInfo} * 'x-5y4z3': {@link WorldData.VoxelInfo} * 'x7y1z8': {THREE.Mesh} * } *&lt;/code&gt;&lt;/pre&gt; * @memberOf WorldData * @typedef {Object} worldData */ /*------------------------------------* :: Class Variables *------------------------------------*/ let worldData /*------------------------------------* :: Public Methods *------------------------------------*/ /** * Initializes the module. Must be called * before anything else * @memberOf WorldData * @access public */ function init() { let secPerSide = Config.getGrid().sectionsPerSide worldData = {} } /** * Load all of the world data into the scene * @memberOf WorldData * @access public * @param {object} data Contains all of the data * to load in, retrieved via the SocketHandler */ function loadIntoScene(data) { console.log('loading voxels into scene ...') ; (function initVoxels() { data.forEach(function(voxel) { if (VoxelUtils.validBlockLocation(voxel.position)) { let vPos = voxel.position let gPos = new THREE.Vector3(vPos.x, vPos.y, vPos.z).initGridPos() let hColor = voxel.color let tColor = new THREE.Color(hColor) VoxelActions.createVoxelAtGridPos(gPos, '#' + tColor.getHexString()) } }) }()) console.log('done loading voxels') GameScene.render() } /** * Get the voxels currently in the scene as an array * @memberOf WorldData * @access public * @return {Object[]} Array of voxels */ function getVoxelsArr() { let voxelsArr = [] for (let coordStr in worldData) { if (worldData.hasOwnProperty(coordStr)) { let gPos = VoxelUtils.coordStrParse(coordStr) let hColor = worldData[coordStr].material.color.getHex() voxelsArr.push({ position: (function() { delete gPos.isGridPos return gPos }()), color: hColor }) } } return voxelsArr } /** * Add a mesh to the world data * @memberOf WorldData * @access public * @param {VoxelUtils.coordStr} coordStr coordinate string of the voxel * @param {THREE.Mesh} mesh The mesh to add */ function addMesh(gPos, mesh) { let coordStr = VoxelUtils.getCoordStr(gPos) worldData[coordStr] = mesh } /** * Remove a voxel from worldData * @memberOf WorldData * @access public * @param {VoxelUtils.GridVector3} gPos Grid position of * the voxel to remove */ function removeVoxel(gPos) { let coordStr = VoxelUtils.getCoordStr(gPos) delete worldData[coordStr] } /**************** getters ******************/ /** * Retrieve a voxel with the specified * grid position * @access public * @memberOf WorldData * @param {VoxelUtils.GridVector3} gPos Grid position of * the voxel to get * @return {object} The mesh or object */ function getVoxel(gPos) { let coordStr = VoxelUtils.getCoordStr(gPos) return worldData[coordStr] } /** * Return the worldData object * @return {Ojbect} The world data */ function getWorldData() { return worldData } /*********** expose public methods *************/ return { init: init, loadIntoScene: loadIntoScene, getVoxel: getVoxel, addMesh: addMesh, getWorldData: getWorldData, removeVoxel: removeVoxel, getVoxelsArr: getVoxelsArr } }() Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Classes Classes Tuple Namespaces AdminGUI GameScene GUIButtons GUIControlKit Keys Main MapControls Mouse Raycast SocketHandler User Validation VoxelActions VoxelUtils WorldData Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespaces Classes Tuple Namespaces AdminGUI GameScene GUIButtons GUIControlKit Keys Main MapControls Mouse Raycast SocketHandler User Validation VoxelActions VoxelUtils WorldData Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Simple in-browser voxel editor with export to OBJ + MTL. Modified from https://github.com/dyarbrough93/PixelScape https://voxel-y.herokuapp.com Resolving yarn.lock conflictsFrom https://github.com/yarnpkg/yarn/issues/1776#issuecomment-269539948 The approach that has worked for me so far is this: git rebase origin/master When the first conflict arises, I checkout the yarn.lock then re-perform the installation git checkout origin/master -- yarn.lock yarn installThis generates a new yarn.lock based on the origin/master version of yarn.lock, but including the changes I made to &gt;my package.json. Then it's just a matter of: git add yarn.lock git rebase --continueAnd I'm back in business. Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"AdminGUI.html":{"id":"AdminGUI.html","title":"Namespace: AdminGUI","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: AdminGUI AdminGUI Source: classes/Admin.js, line 3 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"GameScene.html":{"id":"GameScene.html","title":"Namespace: GameScene","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: GameScene GameScene Manages the game scene (camera, scene, lights, etc) and related game assets Source: classes/GameScene.js, line 3 Methods &lt;static&gt; addToScene(obj) Adds an object to the scene Parameters: Name Type Description obj THREE.Object The object to add Source: classes/GameScene.js, line 422 &lt;static&gt; init() Initializes the game scene. Must be called before anything else. Source: classes/GameScene.js, line 60 &lt;static&gt; initFloorGrid(gridSize) Setup the floor grid Parameters: Name Type Description gridSize Number Grid size Source: classes/GameScene.js, line 268 &lt;static&gt; initVoxelPlane(size) Setup the voxel plane with the given size Parameters: Name Type Description size Number Size of the plane Source: classes/GameScene.js, line 239 &lt;private, static&gt; onWindowResize() Resizes on the scene when the window is resized Source: classes/GameScene.js, line 481 &lt;static&gt; removeCanvas() Remove the canvas from the game container Source: classes/GameScene.js, line 441 &lt;static&gt; removeFromScene(obj) Remove an object from the scene Parameters: Name Type Description obj THREE.Object The object to remove Source: classes/GameScene.js, line 432 &lt;static&gt; render() Renders the scene Source: classes/GameScene.js, line 227 &lt;static&gt; setDeleteMeshVis(visible) Turn the delete mesh visibility on or off Parameters: Name Type Description visible boolean set visiblity Source: classes/GameScene.js, line 314 &lt;static&gt; setDirLightPos(position, target) Set the position and target of the direcitonal light Parameters: Name Type Description position VoxelUtils.WorldVector3 World position to set target VoxelUtils.WorldVector3 What the light should look at (optional) Source: classes/GameScene.js, line 452 &lt;static&gt; setGhostMeshColor(hColor) Set the color of the ghost mesh Parameters: Name Type Description hColor number Hex color to set Source: classes/GameScene.js, line 334 &lt;static&gt; setGhostMeshVis(visible) Turn the ghost mesh visibility on or off Parameters: Name Type Description visible boolean set visibility Source: classes/GameScene.js, line 324 &lt;static&gt; switchRenderer() Switch between the antialiasing renderer and the non-antialiasing renderer Source: classes/GameScene.js, line 402 &lt;static&gt; updateDeleteMesh(intersect) Update the position and visibility of the delete mesh based on the given intersect Parameters: Name Type Description intersect THREE.Intersect The intersect used to set the position Source: classes/GameScene.js, line 377 &lt;static&gt; updateGhostMesh(intersect) Update the position / visibility of the ghost mesh based on the given intersect Parameters: Name Type Description intersect THREE.Intersect The intersect used to set the position Source: classes/GameScene.js, line 347 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"GUIButtons.html":{"id":"GUIButtons.html","title":"Namespace: GUIButtons","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: GUIButtons GUIButtons Manages the game's bootstrap GUI buttons Source: classes/GUIButtons.js, line 3 Methods &lt;private, static&gt; exportVoxels() Get the OBJ + MTL files for this project Source: classes/GUIButtons.js, line 77 &lt;private, static&gt; hideLogin(animSpeed) Hide the login modal Parameters: Name Type Description animSpeed Number Speed to animate at Source: classes/GUIButtons.js, line 117 &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/GUIButtons.js, line 30 &lt;private, static&gt; initDownloadButtons() Initialize the download buttons Source: classes/GUIButtons.js, line 200 &lt;private, static&gt; initLoginModal() Initilize the login modal Source: classes/GUIButtons.js, line 169 &lt;private, static&gt; initModals() Initialize some standard modal behavior Source: classes/GUIButtons.js, line 147 &lt;private, static&gt; initProjectModals() Initialize the new project / show projects modals Source: classes/GUIButtons.js, line 246 &lt;static&gt; saveAsProject() Save current work as a new project Source: classes/GUIButtons.js, line 51 &lt;private, static&gt; showLogin(animSpeed) Show the login modal Parameters: Name Type Description animSpeed Number Speed to animate at Source: classes/GUIButtons.js, line 90 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"GUIControlKit.html":{"id":"GUIControlKit.html","title":"Namespace: GUIControlKit","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: GUIControlKit GUIControlKit Manages the game's ControlKit GUI Source: classes/GUIControlKit.js, line 3 Methods &lt;static&gt; getBlockColor() Get the current block color Source: classes/GUIControlKit.js, line 119 Returns: The block color Type number &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/GUIControlKit.js, line 27 &lt;private, static&gt; initControlKit() Add the necessary elements to the gui Source: classes/GUIControlKit.js, line 196 &lt;private, static&gt; pushToSavedColors() Push the old block color to our saved colors Source: classes/GUIControlKit.js, line 294 &lt;private, static&gt; randomHexColor() Get a random hex color Source: classes/GUIControlKit.js, line 314 Returns: The random hex color Type number &lt;static&gt; setClicked() Set clicked to true or false Source: classes/GUIControlKit.js, line 140 &lt;static&gt; setCoords(planeIntx) Display the currently hovered coordinates in the GUI Parameters: Name Type Description planeIntx THREE.Intersect The plane intersect Source: classes/GUIControlKit.js, line 150 &lt;static&gt; setPickColor(intersect) Given an intersect, extract the color of the intersected block (if it was a block that was intersected) and assign it to the blockColor + update the Game scenes ghost mesh Parameters: Name Type Description intersect THREE.Intersect The intersect Source: classes/GUIControlKit.js, line 82 &lt;private, static&gt; setRandomBlockColor() Set the block color to a random color Source: classes/GUIControlKit.js, line 281 &lt;private, static&gt; showModal() Show the welcome modal Source: classes/GUIControlKit.js, line 272 &lt;private, static&gt; togglePickColor() If the pick color button is clicked, set the users state to pickcolor Source: classes/GUIControlKit.js, line 165 &lt;static&gt; wasClicked() Return whether or not the GUI was click before the mouse click event was received Source: classes/GUIControlKit.js, line 130 Returns: The block color Type number Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"Keys.html":{"id":"Keys.html","title":"Namespace: Keys","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: Keys Keys Manages and routes keyboard events Source: classes/Keys.js, line 3 Methods &lt;private, static&gt; addEventListeners() Add keyboard event listeners to the document Source: classes/Keys.js, line 93 &lt;private, static&gt; ctrlDown() Handle a control down event Source: classes/Keys.js, line 190 &lt;private, static&gt; ctrlUp() Handle a control up event Source: classes/Keys.js, line 199 &lt;private, static&gt; escDown() Handle an escape down event Source: classes/Keys.js, line 165 &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/Keys.js, line 25 &lt;static&gt; isCtrlDown() Is the control key currently down? Source: classes/Keys.js, line 53 Returns: Type boolean &lt;static&gt; isShiftDown() Is the shift key currently down? Source: classes/Keys.js, line 43 Returns: Type boolean &lt;private, static&gt; keyDown(e) Route keydown events Parameters: Name Type Description e Event Source: classes/Keys.js, line 118 &lt;private, static&gt; keyUp(e) Route keyup events Parameters: Name Type Description e Event Source: classes/Keys.js, line 144 &lt;private, static&gt; removeEventListeners() Remove keyboard event listeners from the document Source: classes/Keys.js, line 105 &lt;static&gt; setCtrlDown(value) Set the state of the control key. This is needed in scearios where the key events are not triggered (window out of focus) Parameters: Name Type Description value boolean Value to set it to Source: classes/Keys.js, line 66 &lt;static&gt; setShiftDown(value) Set the state of the shift key. This is needed in scearios where the key events are not triggered (window out of focus) Parameters: Name Type Description value boolean Value to set it to Source: classes/Keys.js, line 80 &lt;private, static&gt; shiftDown() Handle a shift down event Source: classes/Keys.js, line 180 &lt;private, static&gt; shiftUp() Handle a shift up event Source: classes/Keys.js, line 208 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"Main.html":{"id":"Main.html","title":"Namespace: Main","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: Main Main Initializes all classes and triggers loading of data into scene Source: Main.js, line 3 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"MapControls.html":{"id":"MapControls.html","title":"Namespace: MapControls","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: MapControls MapControls Handles the zoom, pan, and rotate controls Source: classes/MapControls.js, line 10 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"Mouse.html":{"id":"Mouse.html","title":"Namespace: Mouse","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: Mouse Mouse Manages and routes Mouse events Source: classes/Mouse.js, line 3 Methods &lt;private, static&gt; addEventListeners() Add mouse event listeners to the document Source: classes/Mouse.js, line 203 &lt;static&gt; forceTriggerMouseMove() Force trigger a mouse move event. This is needed when certain changes are made that require the specific functionality of the mouse move event but cannot be extracted into another function Source: classes/Mouse.js, line 43 &lt;private, static&gt; getMouseIntersects(e) This gets the objects that the mouse is currently intersecting based on the event\\ Parameters: Name Type Description e Event Source: classes/Mouse.js, line 169 Returns: Type object closestIntx is the object the mouse intersected that the is closest to the raycast origin. planeIntx is the voxelPlane intersect, if there is one Type Object &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/Mouse.js, line 25 &lt;private, static&gt; leftDown(e) Handle a left mouse button down event Parameters: Name Type Description e Event Source: classes/Mouse.js, line 85 &lt;private, static&gt; leftDown(e) Handle a left mouse button down event Parameters: Name Type Description e Event Source: classes/Admin.js, line 124 &lt;private, static&gt; mouseDown(e) Route a mouse down event Parameters: Name Type Description e Event Source: classes/Mouse.js, line 69 &lt;private, static&gt; mouseMove(e) Handle a mouse move event Parameters: Name Type Description e Event Source: classes/Mouse.js, line 130 &lt;private, static&gt; removeEventListeners() Remove mouse event listeners to the document Source: classes/Mouse.js, line 216 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"Raycast.html":{"id":"Raycast.html","title":"Namespace: Raycast","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: Raycast Raycast Manages raycasting operations Source: classes/Raycast.js, line 3 Methods &lt;static&gt; add(mesh) Add a mesh to raycast against Parameters: Name Type Description mesh THREE.Mesh The mesh Source: classes/Raycast.js, line 37 &lt;static&gt; getIntersects(pos, camera) Get intersects based on the given position and camera Parameters: Name Type Description pos number The position camera THREE.Camera The camera Source: classes/Raycast.js, line 67 Returns: Array of intersects Type Array.&lt;Object&gt; &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/Raycast.js, line 26 &lt;static&gt; remove(The) Stop raycasting against a mesh Parameters: Name Type Description The THREE.Mesh mesh Source: classes/Raycast.js, line 48 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"SocketHandler.html":{"id":"SocketHandler.html","title":"Namespace: SocketHandler","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: SocketHandler SocketHandler Manages socket events Source: classes/SocketHandler.js, line 3 Methods &lt;static&gt; cacheTempUser(uname) Tells the server to make a temporary cache for some user data so it can be recovered on page reload Parameters: Name Type Description uname string Temp username (not yet confirmed registered) Source: classes/SocketHandler.js, line 41 &lt;static&gt; createProject(pjtName, voxels, cb) Create a new project with the given name / initial voxels Parameters: Name Type Description pjtName string Name of the new project voxels Array.&lt;Object&gt; Array of voxels to add to the project cb function Callback to execute on completion Source: classes/SocketHandler.js, line 80 &lt;static&gt; emitBlockAdded(gPos, hexString, cb) Send a &quot;block added&quot; socket emit with the given grid position and color Parameters: Name Type Description gPos VoxelUtils.GridVector3 The grid position of the voxel to add hexString string Hex color of the voxel we are adding cb function Callback to call with a boolean indicating success Source: classes/SocketHandler.js, line 119 &lt;static&gt; emitBlockRemoved(gPos, cb) Send a &quot;block removed&quot; socket emit with the given grid position Parameters: Name Type Description gPos VoxelUtils.GridVector3 The grid position of the voxel to remove cb function Callback to call with a boolean indicating success Source: classes/SocketHandler.js, line 94 &lt;static&gt; getSocket() Get the socket object Source: classes/SocketHandler.js, line 141 Returns: The socket Type Object &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/SocketHandler.js, line 25 &lt;private, static&gt; initSocketOns() Initialize socket.on events Source: classes/SocketHandler.js, line 154 &lt;static&gt; requestProjects(cb) Get the list of projects for this user from the server Parameters: Name Type Description cb function Callback to execute on completion Source: classes/SocketHandler.js, line 56 &lt;static&gt; saveProject(pjtName, cb) Save the project with the specified name Parameters: Name Type Description pjtName string Name of the project to save cb function Callback to execute on completion Source: classes/SocketHandler.js, line 67 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"User.html":{"id":"User.html","title":"Namespace: User","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: User User Manages and stores information on the user and user state Source: classes/User.js, line 3 Methods &lt;static&gt; canAct() Checks if the user can act based on the actionDelay config setting and the last time acted Source: classes/User.js, line 71 Returns: Type boolean &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/User.js, line 32 &lt;static&gt; resetActionTimer() Reset the action timer to delay actions again Source: classes/User.js, line 59 &lt;static&gt; setDefaultState() Set the user state to default Source: classes/User.js, line 83 &lt;static&gt; setPickState() Set the user state to PICKCOLOR Source: classes/User.js, line 93 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"Validation.html":{"id":"Validation.html","title":"Namespace: Validation","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: Validation Validation A class to assist with validating function arguments. Source: classes/Validation.js, line 1 Methods &lt;static&gt; IllegalArgumentException() An illegal argument exception Source: classes/Validation.js, line 12 &lt;static&gt; validateArguments(args, types, func) Takes an arguments object, an array of types, and a function and verifies that the number of arguments matches the number of types, that all arguments are defined, and that all arguments match their respective type in the &quot;types&quot; array. If an instance validation function is passed, it will be used for type validation. If something is invalid, an appropriate error is thrown. Parameters: Name Type Description args arguments Arguments property of the function we are validating types Array Array of types to check against arguments. These should be strings of javascript types or validation instance functions. e.g. ['string', 'number', 'object'] func function The function we are validating Source: classes/Validation.js, line 108 &lt;static&gt; validateArgumentTypes(args, types) Helper function for validateArguments. Checks the arguments against the array of types and makes sure the types are correct Parameters: Name Type Description args arguments Arguments property of the function we are validating types Array Array of types to check against arguments. These should be strings of javascript types or validation instance functions. e.g. ['string', 'number', 'object'] Source: classes/Validation.js, line 53 Returns: Index of the invalid argument, -1 if none Type number &lt;static&gt; validateLenAndDefined(args, len) Helper function for validateArguments. Checks the arguments and ensures that none of them are undefined and that the length matches the parameter length Parameters: Name Type Description args arguments Arguments property of the function we are validating len number How long the arguments array should be Source: classes/Validation.js, line 26 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"VoxelActions.html":{"id":"VoxelActions.html","title":"Namespace: VoxelActions","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: VoxelActions VoxelActions This module manages the creation and deletion of voxels Source: classes/VoxelActions.js, line 3 Methods &lt;static&gt; createVoxelAtGridPos(gPos, hexString) Creates a voxel mesh at the specified grid position Parameters: Name Type Description gPos VoxelUtils.GridVector3 The grid position to create the voxel at hexString string Hex color of the voxel Source: classes/VoxelActions.js, line 23 &lt;static&gt; createVoxelAtIntersect(intersect, done) Creates a voxel at a position based on the given intersect Parameters: Name Type Description intersect THREE.Intersect The intersect done function Called upon completion Source: classes/VoxelActions.js, line 49 &lt;private, static&gt; deleteVoxelAtGridPos(gPos) Deletes a specified voxel mesh. This is a voxel that has been added to the selected region since its selection Parameters: Name Type Description gPos VoxelUtils.GridVector3 Grid position of the voxel to delete Source: classes/VoxelActions.js, line 136 &lt;static&gt; deleteVoxelAtIntersect(intersect, done) Deletes a voxel at a position based on the given intersect Parameters: Name Type Description intersect THREE.Intersect The intersect done function Called upon completion Source: classes/VoxelActions.js, line 98 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"VoxelUtils.html":{"id":"VoxelUtils.html","title":"Namespace: VoxelUtils","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: VoxelUtils VoxelUtils Contains a number of utility functions for working with voxels Source: classes/VoxelUtils.js, line 3 Classes Tuple Methods &lt;static&gt; coordStrParse(coordStr) Takes a coordinate string, parses it and returns it as a THREE.Vector3. Parameters: Name Type Description coordStr VoxelUtils.coordStr Coordinate string representing a grid position Source: classes/VoxelUtils.js, line 175 Returns: Parsed position vector Type THREE.Vector3 &lt;static&gt; countObjAttrs(obj) Counts the number of root attributes in an object. Parameters: Name Type Description obj object The object Source: classes/VoxelUtils.js, line 310 Returns: Type number &lt;static&gt; getCoordStr(gPos) Takes a THREE.Vector3 and converts it to a coordinate string. Parameters: Name Type Description gPos VoxelUtils.GridVector3 Position in grid coordinates Source: classes/VoxelUtils.js, line 200 Returns: Grid coordinate string Type VoxelUtils.coordStr &lt;static&gt; getGridPositionFromIntersect(intersect) Get the grid position from an intersect Parameters: Name Type Description intersect THREE.Intersect The intersect Source: classes/VoxelUtils.js, line 325 Returns: Grid position, null on none Type VoxelUtils.GridVector3 &lt;static&gt; hexStringToDec(hexString) Convert a hexadecimal string to decimal Parameters: Name Type Description hexString string The hex string Source: classes/VoxelUtils.js, line 360 Returns: The decimal value Type number &lt;static&gt; hexStringToRgb(hexString) Convert a hexadecimal string to RGB Parameters: Name Type Description hexString string The hex string Source: classes/VoxelUtils.js, line 371 Returns: RGB object Type Object &lt;static&gt; initVoxel(args) Initializes a voxel mesh with the specified position Parameters: Name Type Description args object Voxel parameters Properties Name Type Description gPos GridVector3 Grid position color number Hex color Source: classes/VoxelUtils.js, line 278 Returns: The threejs voxel mesh Type THREE.Mesh &lt;static&gt; String#isCoordStr() Check if a string is propery formatted as a VoxelUtils.coordStr Source: classes/VoxelUtils.js, line 43 Returns: Type boolean &lt;static&gt; THREE.Color#getHashHexString() Get a hash hex string ('#1f3c5d86') from a THREE.Color Source: classes/VoxelUtils.js, line 54 Returns: The hash hex string Type string &lt;static&gt; THREE.Vector3#gridToWorld() Converts a THREE.Vector3's values from grid coordinates to world coordinates. Source: classes/VoxelUtils.js, line 102 &lt;static&gt; THREE.Vector3#initGridPos() Marks this vector as a grid position (game coordinates). Source: classes/VoxelUtils.js, line 122 Returns: This object Type VoxelUtils.GridVector3 &lt;static&gt; THREE.Vector3#initWorldPos() Marks this vector as a world position (scene coordinates). Source: classes/VoxelUtils.js, line 133 Returns: This object Type VoxelUtils.WorldVector3 &lt;static&gt; THREE.Vector3#snapToGrid() Sets a THREE.Vector3's values to the center of the closest world &quot;anchor&quot;. I.e. the position that would be used to set the world coordinates of a voxel at that location (multiples of 50 for x and z, (multiples of 50) + 25 for y). Source: classes/VoxelUtils.js, line 67 &lt;static&gt; THREE.Vector3#worldToGrid() Converts a THREE.Vector3's values from world coordinates to grid coordinates. Source: classes/VoxelUtils.js, line 80 &lt;static&gt; validBlockLocation(gPos) Check if the given position is both within the selection bounds and less than the global height limit Parameters: Name Type Description gPos VoxelUtils.GridVector3 The position we are checking Source: classes/VoxelUtils.js, line 242 Returns: Type boolean &lt;static&gt; validHeight(gPos) Check if the given position is within the global height limit Parameters: Name Type Description gPos VoxelUtils.GridVector3 The position Source: classes/VoxelUtils.js, line 213 Returns: Type boolean &lt;static&gt; withinGridBoundaries(gPos) Checks if a position is within the boundaries of the grid Parameters: Name Type Description gPos VoxelUtils.GridVector3 The grid position Source: classes/VoxelUtils.js, line 254 Returns: Type boolean Type Definitions coordStr A coordinate string defining the grid position of a voxel. Formatted as &quot;x[-]{0,1}[0-9]+y[-]{0,1}[0-9]+z[-]{0,1}[0-9]+&quot;. So &quot;x-12y3z15&quot; (x: -12, y: 3, z: 15) would be a valid example. Type: string Source: classes/VoxelUtils.js, line 9 GridVector3 A THREE.Vector3 that represents a grid coordinate. Can be initialized with &quot;new THREE.Vector3().initGridPos()&quot;, or by calling &quot;vec3.worldToGrid()&quot;. Type: THREE.Vector3 Source: classes/VoxelUtils.js, line 17 WorldVector3 A THREE.Vector3 that represents a world coordinate. Can be initialized with &quot;new THREE.Vector3().initWorldPos()&quot;, or by calling &quot;vec3.gridToWorld()&quot;. Type: THREE.Vector3 Source: classes/VoxelUtils.js, line 25 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"VoxelUtils.Tuple.html":{"id":"VoxelUtils.Tuple.html","title":"Class: Tuple","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Class: Tuple VoxelUtils. Tuple new Tuple() Tuple object. Properties: Name Type Description a number First value b number Second value Source: classes/VoxelUtils.js, line 138 Methods isValidTuple() Checks is this is valid tuple. For validation Source: classes/VoxelUtils.js, line 151 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "},"WorldData.html":{"id":"WorldData.html","title":"Namespace: WorldData","body":" Voxely Namespaces AdminGUIGameSceneGUIButtonsGUIControlKitKeysMainMapControlsMouseRaycastSocketHandlerUserValidationVoxelActionsVoxelUtilsWorldData Classes VoxelUtils.Tuple Namespace: WorldData WorldData Manages the world state (location and color of all voxels) Source: classes/WorldData.js, line 3 Methods &lt;static&gt; addMesh(coordStr, mesh) Add a mesh to the world data Parameters: Name Type Description coordStr VoxelUtils.coordStr coordinate string of the voxel mesh THREE.Mesh The mesh to add Source: classes/WorldData.js, line 123 &lt;static&gt; getVoxel(gPos) Retrieve a voxel with the specified grid position Parameters: Name Type Description gPos VoxelUtils.GridVector3 Grid position of the voxel to get Source: classes/WorldData.js, line 151 Returns: The mesh or object Type object &lt;static&gt; getVoxelsArr() Get the voxels currently in the scene as an array Source: classes/WorldData.js, line 95 Returns: Array of voxels Type Array.&lt;Object&gt; &lt;static&gt; init() Initializes the module. Must be called before anything else Source: classes/WorldData.js, line 43 &lt;static&gt; loadIntoScene(data) Load all of the world data into the scene Parameters: Name Type Description data object Contains all of the data to load in, retrieved via the SocketHandler Source: classes/WorldData.js, line 58 &lt;static&gt; removeVoxel(gPos) Remove a voxel from worldData Parameters: Name Type Description gPos VoxelUtils.GridVector3 Grid position of the voxel to remove Source: classes/WorldData.js, line 135 Type Definitions worldData An object containing information on all of the voxels currently in the world, where keys are VoxelUtils.coordStr and values can be either a THREE.Mesh (a newly placed voxel) or a WorldData.VoxelInfo The structure looks like this: { 'x12y10z-5': WorldData.VoxelInfo 'x-5y4z3': WorldData.VoxelInfo 'x7y1z8': {THREE.Mesh} } Type: Object Source: classes/WorldData.js, line 10 Ã— Search results Close Documentation generated by JSDoc 3.4.3 on Sat May 13th 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
